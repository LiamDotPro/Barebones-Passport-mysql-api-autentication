{"version":3,"sources":["../../lib/baseUserFunctions.js"],"names":["baseUserFunctions","new","target","TypeError","password","saltRounds","hash","then","email","using","connection","query","toLowerCase","_res","length","comparePasswords","Password","res","msg","payload","user","id","plainText","compare","catch","e","console","log"],"mappings":"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","file":"baseUserFunctions.js","sourcesContent":["import getSqlConnection from '../lib/db';\r\nimport Promise from 'bluebird';\r\nimport bcrypt from 'bcrypt';\r\n\r\n/**\r\n * Abstract class that acts as the concrete functions for our registering api.\r\n */\r\nexport default class baseUserFunctions {\r\n\r\n    constructor(){\r\n        if (new.target === baseUserFunctions) {\r\n            throw new TypeError(\"Cannot construct Abstract instances directly\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encrypts plain text passwords using a safe encryption method.\r\n     * @param password String\r\n     */\r\n    encryptPassword(password) {\r\n        const saltRounds = 10;\r\n\r\n        return bcrypt.hash(password, saltRounds).then(function (hash) {\r\n            return hash;\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Validates a user from within the database.\r\n     * @param email\r\n     * @param password\r\n     */\r\n    validateUser(email, password) {\r\n        return Promise.using(getSqlConnection(), (connection) => {\r\n            return connection.query('Select id, userName, Password FROM `accounts` Where userName=?', [email.toLowerCase()]).then((_res) => {\r\n                // Check if we have that account.\r\n                if (_res.length > 0) {\r\n                    return this.comparePasswords(_res[0].Password, password).then((res) => {\r\n                        if (res) {\r\n                            return {\r\n                                msg: 'Success',\r\n                                payload: 11,\r\n                                user: {\r\n                                    id: _res[0].id\r\n                                }\r\n                            }\r\n                        } else {\r\n                            return {\r\n                                msg: 'Fail',\r\n                                payload: 1\r\n                            }\r\n                        }\r\n                    })\r\n                } else {\r\n                    return {\r\n                        msg: 'Fail',\r\n                        payload: 1\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This does a simple bcrypt comparision to identify correctness.\r\n     * @param hash\r\n     * @param plainText\r\n     */\r\n    comparePasswords(hash, plainText) {\r\n        return bcrypt.compare(plainText, hash).then((res) => {\r\n            return res === true;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This checks for a duplicate account inside the database.\r\n     * Payload is a boolean Int\r\n     */\r\n    checkForDuplicateAccount(email) {\r\n        return Promise.using(getSqlConnection(), (connection) => {\r\n            return connection.query('SELECT `userName` FROM `accounts` WHERE userName=?', [email.toLowerCase()]).then((res) => {\r\n                if (res.length === 0) {\r\n                    return {\r\n                        msg: 'Success',\r\n                        payload: 0\r\n                    }\r\n                } else {\r\n                    return {\r\n                        msg: 'Fail - Duplicate Account',\r\n                        payload: 1\r\n                    }\r\n                }\r\n            }).catch((e) => {\r\n                console.log(e);\r\n            })\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Find Account by Id\r\n     */\r\n    findAccountById(id) {\r\n        return Promise.using(getSqlConnection(), (connection) => {\r\n            return connection.query('SELECT `id` FROM `accounts` WHERE id=?', [id]).then((res) => {\r\n                if (res.length > 0) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            })\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This is the last part of the system.\r\n     * All passwords should be ran through bcrypt before being inserted.\r\n     * @param email\r\n     * @param password\r\n     */\r\n    createAccount(email, password) {\r\n        return Promise.using(getSqlConnection(), (connection) => {\r\n            return connection.query('INSERT INTO `accounts` (userName, Password) VALUES (?, ?)', [email.toLowerCase(), password]).then((res) => {\r\n                return {msg: 'Success', payload: 10}\r\n            })\r\n        }).catch((e) => {\r\n            console.log(e);\r\n        });\r\n    }\r\n\r\n}"]}